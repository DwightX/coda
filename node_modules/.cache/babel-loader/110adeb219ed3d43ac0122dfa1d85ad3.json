{"ast":null,"code":"import { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nimport { getEventDataFromMockedApi } from \"../api\";\nconst initialState = {\n  ids: [],\n  entities: []\n}; // The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(fetchDeviceEvents())`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\n\nexport const fetchDeviceEvents = createAsyncThunk(\"fetchDeviceEvents\", async () => {\n  try {\n    return await getEventDataFromMockedApi();\n  } catch (e) {\n    return Promise.reject(e);\n  }\n});\nexport const deviceEvents = createSlice({\n  name: \"deviceEvents\",\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    clickDeviceEvent(state, action) {\n      state.selectedId = action.payload;\n    }\n\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: builder => {\n    builder.addCase(fetchDeviceEvents.pending, state => {\n      state.status = \"pending\";\n    }).addCase(fetchDeviceEvents.fulfilled, (state, action) => {\n      state.status = \"fulfilled\";\n      const initializer = {\n        ids: [],\n        entities: {}\n      };\n      const nextState = action.payload.reduce((accumulator, deviceEvent) => {\n        return { ...accumulator,\n          ids: [...accumulator.ids, deviceEvent.id],\n          entities: { ...accumulator.entities,\n            [deviceEvent.id]: { ...deviceEvent\n            }\n          }\n        };\n      }, initializer);\n      state.ids = nextState.ids;\n      state.entities = nextState.entities;\n    }).addCase(fetchDeviceEvents.rejected, state => {\n      state.status = \"rejected\";\n    });\n  }\n});\nexport const {\n  clickDeviceEvent\n} = deviceEvents.actions; // The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.deviceEvents.selectedId)`\n\nexport function getSelectedEventId(state) {\n  return state.deviceEvents.selectedId;\n}\nexport const getAllDeviceEvents = state => {\n  return state.deviceEvents.ids.map(id => {\n    const event = state.deviceEvents.entities[id];\n\n    if (typeof event === \"undefined\") {\n      console.error(`No event for id: ${id}`);\n    }\n\n    return event;\n  });\n};\nconst deviceEventsReducer = deviceEvents.reducer;\nexport default deviceEventsReducer;","map":{"version":3,"sources":["/Users/bigbrother/Desktop/coda-project/src/reducers/events.ts"],"names":["createAsyncThunk","createSlice","getEventDataFromMockedApi","initialState","ids","entities","fetchDeviceEvents","e","Promise","reject","deviceEvents","name","reducers","clickDeviceEvent","state","action","selectedId","payload","extraReducers","builder","addCase","pending","status","fulfilled","initializer","nextState","reduce","accumulator","deviceEvent","id","rejected","actions","getSelectedEventId","getAllDeviceEvents","map","event","console","error","deviceEventsReducer","reducer"],"mappings":"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","sourcesContent":["import {\n  createAsyncThunk,\n  createSlice,\n  PayloadAction,\n  Reducer,\n} from \"@reduxjs/toolkit\";\nimport { getEventDataFromMockedApi } from \"../api\";\nimport { DeviceEvent } from \"../types\";\nimport { RootState } from \"./store\";\n\nexport interface DeviceEventsState {\n  ids: number[];\n  entities: { [id: number]: DeviceEvent };\n  selectedId?: number;\n  status?: \"pending\" | \"fulfilled\" | \"rejected\";\n}\n\nconst initialState: DeviceEventsState = {\n  ids: [],\n  entities: [],\n};\n\n// The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(fetchDeviceEvents())`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\n\nexport const fetchDeviceEvents = createAsyncThunk(\n  \"fetchDeviceEvents\",\n  async (): Promise<DeviceEvent[]> => {\n    try {\n      return await getEventDataFromMockedApi();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n);\n\nexport const deviceEvents = createSlice({\n  name: \"deviceEvents\",\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    clickDeviceEvent(state, action: PayloadAction<number>) {\n      state.selectedId = action.payload;\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchDeviceEvents.pending, (state) => {\n        state.status = \"pending\";\n      })\n      .addCase(fetchDeviceEvents.fulfilled, (state, action) => {\n        state.status = \"fulfilled\";\n        const initializer: DeviceEventsState = {\n          ids: [],\n          entities: {},\n        };\n        const nextState = action.payload.reduce((accumulator, deviceEvent) => {\n          return {\n            ...accumulator,\n            ids: [...accumulator.ids, deviceEvent.id],\n            entities: {\n              ...accumulator.entities,\n              [deviceEvent.id]: {\n                ...deviceEvent,\n              },\n            },\n          };\n        }, initializer);\n        state.ids = nextState.ids;\n        state.entities = nextState.entities;\n      })\n      .addCase(fetchDeviceEvents.rejected, (state) => {\n        state.status = \"rejected\";\n      });\n  },\n});\n\nexport const { clickDeviceEvent } = deviceEvents.actions;\n\n// The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.deviceEvents.selectedId)`\nexport function getSelectedEventId(state: RootState): number | undefined {\n  return state.deviceEvents.selectedId;\n}\n\nexport const getAllDeviceEvents = (state: RootState): DeviceEvent[] => {\n  return state.deviceEvents.ids.map((id) => {\n    const event = state.deviceEvents.entities[id];\n    if (typeof event === \"undefined\") {\n      console.error(`No event for id: ${id}`);\n    }\n    return event;\n  });\n};\n\nconst deviceEventsReducer: Reducer<DeviceEventsState> = deviceEvents.reducer;\nexport default deviceEventsReducer;\n"]},"metadata":{},"sourceType":"module"}